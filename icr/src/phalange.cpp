#include "../include/phalange.h"
#include <geometry_msgs/PoseStamped.h>
#include <tf_conversions/tf_eigen.h>
#include <Eigen/Core>

Phalange::Phalange(tf::Transform const & L_T_Cref,Model const & model, std::string const & sensor_topic) : nh_private_("~"),L_T_Cref_(L_T_Cref),C_T_L_(new icr::StampedContactPose),
													   model_(new Model(model)), obj_geom_("default")
{
  std::string searched_param;
  nh_private_.searchParam("tf_prefix",searched_param);
  nh_private_.getParam(searched_param, tf_prefix_);

  L_T_Cref_.setRotation(L_T_Cref_.getRotation().normalize());//ensure normalized orientation

  contacts_subs_=nh_.subscribe<gazebo_msgs::ContactsState>(sensor_topic, 1, &Phalange::listenContacts, this);
  ct_pose_pub_=nh_.advertise<geometry_msgs::PoseStamped>(model_->name_ + "/contact_pose",1);
  set_pose_srv_ = nh_.advertiseService(model_->name_ + "/set_ref_contact_pose",&Phalange::setPose,this);
}
//---------------------------------------------------------------------
void Phalange::listenContacts(const gazebo_msgs::ContactsState::ConstPtr& cts_st)
{
  lock_.lock(); 
  geometry_msgs::PoseStamped C_T_L;
  C_T_L.header.stamp=cts_st->header.stamp;
  C_T_L.header.frame_id=tf_prefix_ + model_->frame_id_;
  
  //Check whether the phalange geometry is in contact with the target object geometry
  for(unsigned int i=0; i < cts_st->states.size();i++)
    if((cts_st->states[i].geom1_name == model_->geom_) && (cts_st->states[i].geom2_name == obj_geom_))     
      {
	//Contact position is generated by averaging over all points in the message
	tf::pointTFToMsg(averageVectors(cts_st->states[i].contact_positions),C_T_L.pose.position);
        //Contact pose is generated via projecting the pose of the link frame on the nullspace of
        //the average normal specified in the message
	tf::quaternionTFToMsg(projectPose(averageVectors(cts_st->states[i].contact_normals)).normalize(),C_T_L.pose.orientation);
       
        ct_pose_pub_.publish(C_T_L);//Publish the contact pose 
        
        C_T_L_->header=C_T_L.header;
        C_T_L_->contact_pose.pose=C_T_L.pose;
        C_T_L_->contact_pose.touching=true;  //Phalange geometry and target object geometry are in contact

        lock_.unlock();
        return;
      }    
 
  //Publish the reference contact pose if no contact is made
  tf::pointTFToMsg(L_T_Cref_.getOrigin(),C_T_L.pose.position);
  tf::quaternionTFToMsg(L_T_Cref_.getRotation(),C_T_L.pose.orientation);

  ct_pose_pub_.publish(C_T_L);

  C_T_L_->header=C_T_L.header;
  C_T_L_->contact_pose.pose=C_T_L.pose;
  C_T_L_->contact_pose.touching=false;

  lock_.unlock();
}
//---------------------------------------------------------------------
bool Phalange::setTargetObjGeom(std::string const & obj_geom)
{
  if(obj_geom.empty())
    {
      ROS_ERROR("Invalid traget object geometry");
      return false;
    }

  lock_.lock();
  obj_geom_=obj_geom;
  lock_.unlock();
  return true;
}
//---------------------------------------------------------------------
tf::Vector3 Phalange::averageVectors(std::vector<geometry_msgs::Vector3> const & vecs)
{
  tf::Vector3 avg_v(0,0,0);

  //Not very nice to return a zero vector in case of an empty input list, but well ...
  if (vecs.size()==0)
    return avg_v;        

  for (unsigned int i=0; i < vecs.size();i++ )
    avg_v+=tf::Vector3(vecs[i].x,vecs[i].y,vecs[i].z);
  

  return avg_v/=vecs.size();
}
//---------------------------------------------------------------------
tf::Quaternion Phalange::projectPose(tf::Vector3 const & z)
{
  tf::Quaternion ori;
  Eigen::Vector3d z_Cref;  

  //The transposed rotation matrix containing the basis of the new contact frame expressed in the
  //reference contact frame. It is transposed since btMatrix3x3 only allows row-wise access
  btMatrix3x3 Cref_R_C;

  //Express z (given in the link frame) in the contact reference frame
  tf::VectorTFToEigen(L_T_Cref_.inverse()*z,z_Cref); 
  z_Cref.normalize();//Assert unit normal

  //Generate the matrix I-n*n^T for projecting on the nullspace of the new z-axis. The nullspace
  //is perpendicular to z.
  Eigen::Matrix3d P = (Eigen::Matrix3d()).setIdentity()-z_Cref*z_Cref.transpose();
  
  //Project the x & y axis of the contact reference frame - this is unstable if one of these axis is
  //(nearly) orthogonal to the nullspace - there should be some check on the norm of the projections ...
  tf::VectorEigenToTF((P*Eigen::Vector3d(1,0,0)).normalized(),Cref_R_C[0]);
  tf::VectorEigenToTF((P*Eigen::Vector3d(0,1,0)).normalized(),Cref_R_C[1]);
  tf::VectorEigenToTF(z_Cref,Cref_R_C[2]);
    
  //Transformation from the new contact frame to the reference frame
  tf::Transform Cref_T_C(Cref_R_C.transpose(),tf::Vector3(0,0,0));

  //Return the orientation (the position is computed in the listenContacts callback by simply
  //averaging the positions contained in the gazebo_msgs/ContactsState msg)
  return L_T_Cref_*Cref_T_C.getRotation();
}
//---------------------------------------------------------------------
bool Phalange::setPose(icr::SetPose::Request  &req, icr::SetPose::Response &res)
{
  //Sets the pose of the contact reference w.r.t the link frame
  res.success=false;
  lock_.lock();

  L_T_Cref_.setOrigin(tf::Vector3(req.origin.x,req.origin.y,req.origin.z));
  L_T_Cref_.setRotation(tf::createQuaternionFromRPY(req.rpy.x,req.rpy.y,req.rpy.z));

  lock_.unlock();
  res.success=true;
  return res.success;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
boost::shared_ptr<Model> Phalange::getPhalangeModel()
{
  //return a copy for thread safety
  lock_.lock();
  boost::shared_ptr<Model> temp_model(new Model(*model_.get()));
  lock_.unlock();

  return temp_model;
}
//---------------------------------------------------------------------
boost::shared_ptr<icr::StampedContactPose> Phalange::getStampedContactPose()
{
  //return a copy for thread safety
  lock_.lock();
  boost::shared_ptr<icr::StampedContactPose> temp_C_T_L(new icr::StampedContactPose(*C_T_L_.get()));
  lock_.unlock();

  return temp_C_T_L;
}
//---------------------------------------------------------------------
icr::StampedContactPoint::ConstPtr Phalange::getStampedContactPoint()
{

  lock_.lock();

  icr::StampedContactPoint::ConstPtr temp_scp(new icr::StampedContactPoint);

  // temp_scp->header=C_T_L_->header;
  // temp_scp->contact_point.position=C_T_L_->contact_pose.pose.position;
  // temp_scp->contact_point.touching=C_T_L_->contact_pose.touching;
  lock_.unlock();

  return temp_scp;
}
//---------------------------------------------------------------------
boost::shared_ptr<icr::ContactPose> Phalange::getContactPose()
{
  //return a copy for thread safety
  lock_.lock();
  boost::shared_ptr<icr::ContactPose> temp_C_T_L(new icr::ContactPose(C_T_L_->contact_pose));
  lock_.unlock();

  return temp_C_T_L;
}
//---------------------------------------------------------------------
boost::shared_ptr<icr::ContactPoint> Phalange::getContactPoint()
{

  lock_.lock();
  boost::shared_ptr<icr::ContactPoint> temp_cp(new icr::ContactPoint);
  temp_cp->position=C_T_L_->contact_pose.pose.position;
  temp_cp->touching=C_T_L_->contact_pose.touching;
  lock_.unlock();

  return temp_cp;
}
//---------------------------------------------------------------------
